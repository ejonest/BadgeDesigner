// ===== C:\Users\Tom_P\OneDrive\Documents\PSS\2025 - Coding Projects\Badge Tool\badge-designer-frontend\src\constants\badge.ts =====
import type { Badge } from "../types/badge";

export const BADGE_CONSTANTS = {
  MAX_LINES: 4,
  MIN_FONT_SIZE: 8,
  BADGE_WIDTH: 300,
  BADGE_HEIGHT: 100,
} as const;

export const INITIAL_BADGE: Badge = {
  templateId: 'rect-1x3',
  backgroundColor: '#FFFFFF',
  backing: 'pin',
  lines: [
    { text: 'Your Badge Text', size: 18, color: '#000000', bold: false, italic: false, underline: false, fontFamily: 'Roboto', alignment: 'center' },
  ],
  backgroundImage: undefined,
  logo: undefined,
};
// ===== C:\Users\Tom_P\OneDrive\Documents\PSS\2025 - Coding Projects\Badge Tool\badge-designer-frontend\src\types\badge.ts =====
export type TextAlign = 'left' | 'center' | 'right';

export interface BadgeLine {
  text: string;
  size: number;
  color: string;
  bold: boolean;
  italic: boolean;
  underline: boolean;
  fontFamily: string;
  alignment: TextAlign;
}

export interface BadgeImage {
  src: string;
  x: number;
  y: number;
  scale: number; // 1.0 = natural pixels
}

export interface TemplateMaskRect {
  type: 'rect';
  x?: number;
  y?: number;
  width?: number;
  height?: number;
  rx?: number;
  ry?: number;
}

export interface TemplateMaskPath {
  type: 'path';
  d: string;
  /**
   * The original coordinate system (from the source SVG's viewBox).
   * Used to fit the path uniformly into our safe box.
   * Example: [0, 0, 4000, 2819.44]
   */
  sourceViewBox: [number, number, number, number];
}

export type TemplateMask = TemplateMaskRect | TemplateMaskPath;

export interface Template {
  id: string;
  name: string;
  artboardWidth: number;   // px
  artboardHeight: number;  // px
  safeInset?: number;      // px
  mask: TemplateMask;
}

export interface Badge {
  templateId?: string;
  backgroundColor: string;
  backing: 'pin' | 'magnetic' | 'adhesive';
  lines: BadgeLine[];
  backgroundImage?: BadgeImage;
  logo?: BadgeImage;
}.
// ===== C:\Users\Tom_P\OneDrive\Documents\PSS\2025 - Coding Projects\Badge Tool\badge-designer-frontend\src\utils\export.ts =====
import { Badge } from "../types/badge";
import { renderBadgeToSvgString } from "./renderSvg";

export async function downloadSvg(badge: Badge): Promise<void> {
  const { svg } = renderBadgeToSvgString(badge, { templateId: badge.templateId });
  const blob = new Blob([svg], { type: "image/svg+xml" });
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "badge.svg";
  a.click();
  URL.revokeObjectURL(a.href);
}

export async function downloadPng(badge: Badge, scale = 2): Promise<void> {
  const { svg, width, height } = renderBadgeToSvgString(badge, { templateId: badge.templateId });
  const svgUrl = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svg);

  const img = new Image();
  img.crossOrigin = "anonymous";
  await new Promise<void>((res, rej) => {
    img.onload = () => res();
    img.onerror = (e) => rej(e);
    img.src = svgUrl;
  });

  const canvas = document.createElement("canvas");
  canvas.width = Math.round(width * scale);
  canvas.height = Math.round(height * scale);
  const ctx = canvas.getContext("2d")!;
  ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

  canvas.toBlob((blob) => {
    if (!blob) return;
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "badge.png";
    a.click();
    URL.revokeObjectURL(a.href);
  }, "image/png");
}

async function postExport(format: "tiff" | "pdf" | "cdr", badge: Badge): Promise<void> {
  const { svg, width, height } = renderBadgeToSvgString(badge, { templateId: badge.templateId });

  // Select endpoint per format
  const endpoint = format === "tiff"
    ? "/export.tiff"
    : format === "pdf"
    ? "/export.pdf"
    : "/export.cdr";

  const r = await fetch(endpoint, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ svg, width, height, filename: `badge.${format === "cdr" ? "cdr" : format}` }),
  });

  if (!r.ok) throw new Error(`Export failed (${format})`);

  const blob = await r.blob();
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = `badge.${format === "cdr" ? "cdr" : format}`;
  a.click();
  URL.revokeObjectURL(a.href);
}

export const downloadTiff = (badge: Badge) => postExport("tiff", badge);
export const downloadPdf = (badge: Badge) => postExport("pdf", badge);
// CDR = we ship the same SVG but with .cdr filename so Corel opens it
export const downloadCdr = (badge: Badge) => postExport("cdr", badge);.
// ===== C:\Users\Tom_P\OneDrive\Documents\PSS\2025 - Coding Projects\Badge Tool\badge-designer-frontend\src\utils\renderSvg.ts =====
import type { Badge, Template, TemplateMaskPath } from "../types/badge";

function esc(s: string) {
  return s.replace(/[&<>"']/g, (m) => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]!));
}

export function renderBadgeToSvgString(badge: Badge, template: Template, uid?: string): string {
  if (!template || !template.artboardWidth || !template.artboardHeight) {
    throw new Error("Invalid template");
  }

  const W = template.artboardWidth;
  const H = template.artboardHeight;
  // Ensure we have a numeric safe inset
  const safe = typeof template.safeInset === 'number' ? template.safeInset : 0;

  // Inner drawable area (we clip all user content to the mask, but we also use the safe box to position the path nicely)
  const innerX = safe;
  const innerY = safe;
  const innerW = W - safe * 2;
  const innerH = H - safe * 2;

  // Build mask shape
  let maskBody = "";
  if (template.mask.type === "rect") {
    const rx = template.mask.rx ?? 0;
    const ry = template.mask.ry ?? rx;
    const x = template.mask.x ?? 0;
    const y = template.mask.y ?? 0;
    const width = template.mask.width ?? W;
    const height = template.mask.height ?? H;
    maskBody = `<rect x="${x}" y="${y}" width="${width}" height="${height}" rx="${rx}" ry="${ry}" />`;
  } else {
    const mp = template.mask as TemplateMaskPath;
    const [vbX, vbY, vbW, vbH] = mp.sourceViewBox;
    const scale = Math.min(innerW / vbW, innerH / vbH);
    const tx = innerX + (innerW - vbW * scale) / 2 - vbX * scale;
    const ty = innerY + (innerH - vbH * scale) / 2 - vbY * scale;

    // Explicit fill + evenodd rule to ensure the clip region is recognized in all browsers
    maskBody = `<g transform="translate(${tx},${ty}) scale(${scale})">
      <path d="${mp.d}" fill="black" clip-rule="evenodd"/>
    </g>`;
  }

  // ClipPath id - use provided uid or generate unique one
  const idSuffix = uid ? uid.replace(/[^a-zA-Z0-9]/g, '') : Math.random().toString(36).slice(2);
  const clipId = `clip_${idSuffix}`;
  const cutId  = `cut_${idSuffix}`;

  // Background color (under everything, but still clipped)
  const bgColor = badge.backgroundColor || "#FFFFFF";
  
  // Debug: Use a visible color for testing clipping
  const debugBgColor = template.mask.type === 'path' ? "#FF6B6B" : bgColor;

  // Images (optional)
  const bgImg = badge.backgroundImage;
  const logo  = badge.logo;

  // Helper: image tag (clipped)
  const imageTag = (img?: {src:string, x:number, y:number, scale:number}) => {
    if (!img) return "";
    // We draw images in badge coordinate space (artboard px) so x/y/scale are applied directly
    // Using preserveAspectRatio="none" because the user controls scale.
    return `<image href="${esc(img.src)}" x="${img.x}" y="${img.y}" transform="scale(${img.scale})" width="${W}" height="${H}" preserveAspectRatio="none" />`;
  };

  // Text lines (clipped)
  const lineHeightMult = 1.3;
  const totalTextHeight = badge.lines.reduce((acc, l) => acc + l.size * lineHeightMult, 0);
  let yCursor = H / 2 - totalTextHeight / 2;

  const textNodes = badge.lines.map((l) => {
    const anchor = l.alignment === "left" ? "start" : l.alignment === "right" ? "end" : "middle";
    const xPos = l.alignment === "left" ? safe + 8 : l.alignment === "right" ? W - safe - 8 : W / 2;
    const fontW = `${l.bold ? "bold " : ""}${l.italic ? "italic " : ""}${l.size}px ${esc(l.fontFamily || "Arial")}`;
    const out = `<text x="${xPos}" y="${yCursor + l.size}" text-anchor="${anchor}" fill="${esc(l.color)}" font="${esc(fontW)}">${esc(l.text)}</text>`;
    yCursor += l.size * lineHeightMult;
    return out;
  }).join("");

  // Cutline (top overlay) uses the same geometry as the mask (no scaling stroke)
  let cutBody = "";
  if (template.mask.type === "rect") {
    const rx = template.mask.rx ?? 0;
    const ry = template.mask.ry ?? rx;
    const x = template.mask.x ?? 0;
    const y = template.mask.y ?? 0;
    const width = template.mask.width ?? W;
    const height = template.mask.height ?? H;
    cutBody = `<rect x="${x}" y="${y}" width="${width}" height="${height}" rx="${rx}" ry="${ry}" 
      fill="none" stroke="#c14646" stroke-width="2" vector-effect="non-scaling-stroke"/>`;
  } else {
    const mp = template.mask as TemplateMaskPath;
    const [vbX, vbY, vbW, vbH] = mp.sourceViewBox;
    const scale = Math.min(innerW / vbW, innerH / vbH);
    const tx = innerX + (innerW - vbW * scale) / 2 - vbX * scale;
    const ty = innerY + (innerH - vbH * scale) / 2 - vbY * scale;
    cutBody = `<g transform="translate(${tx},${ty}) scale(${scale})">
      <path d="${mp.d}" fill="none" stroke="#c14646" stroke-width="2" vector-effect="non-scaling-stroke"/>
    </g>`;
  }

  // Safe guide (dashed rectangle) â€” visual aid only
  const safeGuide = `<rect x="${innerX}" y="${innerY}" width="${innerW}" height="${innerH}" fill="none" stroke="#e9b7b7" stroke-dasharray="6 6" />`;

  // Debug: log what's being rendered
  // eslint-disable-next-line no-console
  console.log('[renderSvg] Rendering:', {
    templateId: template.id,
    maskType: template.mask.type,
    clipId,
    hasBackground: !!bgColor,
    hasBgImage: !!bgImg,
    hasLogo: !!logo,
    textLines: badge.lines.length,
    maskBody: maskBody.substring(0, 100) + '...'
  });

  // Assemble
  return `
<svg xmlns="http://www.w3.org/2000/svg" width="${W}" height="${H}" viewBox="0 0 ${W} ${H}">
  <defs>
    <clipPath id="${clipId}" clipPathUnits="userSpaceOnUse">
      ${maskBody}
    </clipPath>
    <mask id="${cutId}">
      <rect x="0" y="0" width="${W}" height="${H}" fill="white"/>
    </mask>
  </defs>

  <!-- clipped content -->
  <g clip-path="url(#${clipId})">
    <rect x="0" y="0" width="${W}" height="${H}" fill="${esc(debugBgColor)}"/>
    ${imageTag(bgImg)}
    ${imageTag(logo)}
    ${textNodes}
  </g>

  <!-- overlays -->
  ${safe > 0 ? safeGuide : ""}
  ${cutBody}
</svg>`.trim();
}.
// ===== C:\Users\Tom_P\OneDrive\Documents\PSS\2025 - Coding Projects\Badge Tool\badge-designer-frontend\src\utils\templates.ts =====
import templatesJson from "../data/templates.local.json";
import type { Template } from "../types/badge";

const TEMPLATES: Template[] = templatesJson as Template[];

export function getTemplates(): Template[] {
  return TEMPLATES;
}

export function getTemplateById(id?: string): Template {
  const fallback = TEMPLATES[0];
  if (!id) return fallback;
  return TEMPLATES.find(t => t.id === id) ?? fallback;
}

export type { Template };.
